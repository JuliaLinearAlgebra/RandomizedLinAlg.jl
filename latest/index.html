<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · RandomizedLinAlg.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RandomizedLinAlg.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Condition-number-estimate"><span>Condition number estimate</span></a></li><li><a class="tocitem" href="#Extremal-eigenvalue-estimates"><span>Extremal eigenvalue estimates</span></a></li><li><a class="tocitem" href="#Norm-estimate"><span>Norm estimate</span></a></li><li><a class="tocitem" href="#Interpolative-Decomposition"><span>Interpolative Decomposition</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaLinearAlgebra/RandomizedLinAlg.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Randomized"><a class="docs-heading-anchor" href="#Randomized">Randomized Linear Algebra</a><a id="Randomized-1"></a><a class="docs-heading-anchor-permalink" href="#Randomized" title="Permalink"></a></h1><p>RandomizedLinAlg.jl is a Julia package that provides some randomized algorithms for numerical linear algebra as advocated in <sup class="footnote-reference"><a id="citeref-Halko2011" href="#footnote-Halko2011">[Halko2011]</a></sup>.</p><article class="docstring"><header><a class="docstring-binding" id="RandomizedLinAlg.reigen" href="#RandomizedLinAlg.reigen"><code>RandomizedLinAlg.reigen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reigen(A, l)</code></pre><p>Compute the spectral (<code>Eigen</code>) decomposition of <code>A</code> using a randomized algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: input matrix.</li><li><code>l::Int</code>: number of eigenpairs to find.</li></ul><p><strong>Output</strong></p><ul><li><code>::LinearAlgebra.Eigen</code>: eigen decomposition.</li></ul><p><strong>Implementation note</strong></p><p>This is a wrapper around <code>eigen_onepass()</code> which uses the randomized samples found using <code>srft(l)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/RandomizedLinAlg.jl/blob/d81c5beb5749f5826cdf56c2f02eb7c27058869f/src/rsvd.jl#L504-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RandomizedLinAlg.rsvd" href="#RandomizedLinAlg.rsvd"><code>RandomizedLinAlg.rsvd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rsvd(A, n, p=0)</code></pre><p>Compute partial singular value decomposition of <code>A</code> using a randomized algorithm.</p><p><strong>Arguments</strong></p><p><code>A</code>: input matrix.</p><p><code>n::Int</code>: number of singular value/vector pairs to find.</p><p><code>p::Int=0</code>: number of extra vectors to include in computation.</p><p><strong>Output</strong></p><p><code>::SVD</code>: singular value decomposition.</p><div class="admonition is-warning"><header class="admonition-header">Accuracy</header><div class="admonition-body"><p>This variant of the randomized singular value decomposition is the most commonly found implementation but is not recommended for accurate computations, as it often has trouble finding the <code>n</code> largest singular pairs, but rather finds <code>n</code> large singular pairs which may not necessarily be the largest.</p></div></div><p><strong>Implementation note</strong></p><p>This function calls <code>rrange</code>, which uses naive randomized rangefinding to compute a basis for a subspace of dimension <code>n</code> (Algorithm 4.1 of <sup class="footnote-reference"><a id="citeref-Halko2011" href="#footnote-Halko2011">[Halko2011]</a></sup>), followed by <code>svd_restricted()</code>, which computes the exact SVD factorization on the restriction of <code>A</code> to this randomly selected subspace (Algorithm 5.1 of <sup class="footnote-reference"><a id="citeref-Halko2011" href="#footnote-Halko2011">[Halko2011]</a></sup>).</p><p>Alternatively, you can mix and match your own randomized algorithm using any of the randomized range finding algorithms to find a suitable subspace and feeding the result to one of the routines that computes the <code>SVD</code> restricted to that subspace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/RandomizedLinAlg.jl/blob/d81c5beb5749f5826cdf56c2f02eb7c27058869f/src/rsvd.jl#L13-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RandomizedLinAlg.rsvd_fnkz" href="#RandomizedLinAlg.rsvd_fnkz"><code>RandomizedLinAlg.rsvd_fnkz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rsvd_fnkz(A, k)</code></pre><p>Compute the randomized SVD by iterative refinement from randomly selected columns/rows <sup class="footnote-reference"><a id="citeref-Friedland2006" href="#footnote-Friedland2006">[Friedland2006]</a></sup>.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: matrix whose SVD is desired;</li><li><code>k::Int</code>: desired rank of approximation (<code>k ≤ min(m, n)</code>).</li></ul><p><strong>Keywords</strong></p><ul><li><code>l::Int = k</code>: number of columns/rows to sample at each iteration (<code>1 ≤ l ≤ k</code>);</li><li><code>N::Int = minimum(size(A))</code>: maximum number of iterations;</li><li><code>ϵ::Real = prod(size(A))*eps()</code>: relative threshold for convergence, as measured by growth of the spectral norm;</li><li><code>method::Symbol = :eig</code>: problem to solve.<ol><li><code>:eig</code>: eigenproblem.</li><li><code>:svd</code>: singular problem.</li></ol></li><li><code>verbose::Bool = false</code>: print convergence information at each iteration.</li></ul><p><strong>Return value</strong></p><p>SVD object of <code>rank ≤ k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/RandomizedLinAlg.jl/blob/d81c5beb5749f5826cdf56c2f02eb7c27058869f/src/rsvd_fnkz.jl#L12-L42">source</a></section></article><h2 id="Condition-number-estimate"><a class="docs-heading-anchor" href="#Condition-number-estimate">Condition number estimate</a><a id="Condition-number-estimate-1"></a><a class="docs-heading-anchor-permalink" href="#Condition-number-estimate" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RandomizedLinAlg.rcond" href="#RandomizedLinAlg.rcond"><code>RandomizedLinAlg.rcond</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rcond(A, iters=1)</code></pre><p>Estimate matrix condition number randomly.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: matrix whose condition number to estimate. Must be square and</li></ul><p>support premultiply (<code>A*⋅</code>) and solve (<code>A\⋅</code>).</p><ul><li><code>iters::Int = 1</code>: number of power iterations to run.</li></ul><p><strong>Keywords</strong></p><ul><li><code>p::Real = 0.05</code>: probability that estimate fails to hold as an upper bound.</li></ul><p><strong>Output</strong></p><p>Interval <code>(x, y)</code> which contains <code>κ(A)</code> with probability <code>1 - p</code>.</p><p><strong>Implementation note</strong></p><p><sup class="footnote-reference"><a id="citeref-Dixon1983" href="#footnote-Dixon1983">[Dixon1983]</a></sup> originally describes this as a computation that can be done by computing the necessary number of power iterations given p and the desired accuracy parameter <code>θ=y/x</code>. However, these bounds were only derived under the assumptions of exact arithmetic. Empirically, <code>iters≥4</code> has been seen to result in incorrect results in that the computed interval does not contain the true condition number. This implemention therefore makes <code>iters</code> an explicitly user-controllable parameter from which to infer the accuracy parameter and hence the interval containing <code>κ(A)</code>. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/RandomizedLinAlg.jl/blob/d81c5beb5749f5826cdf56c2f02eb7c27058869f/src/rlinalg.jl#L148-L178">source</a></section></article><h2 id="Extremal-eigenvalue-estimates"><a class="docs-heading-anchor" href="#Extremal-eigenvalue-estimates">Extremal eigenvalue estimates</a><a id="Extremal-eigenvalue-estimates-1"></a><a class="docs-heading-anchor-permalink" href="#Extremal-eigenvalue-estimates" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RandomizedLinAlg.reigmin" href="#RandomizedLinAlg.reigmin"><code>RandomizedLinAlg.reigmin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reigmin(A, iters=1)</code></pre><p>Estimate minimal eigenvalue randomly.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Matrix whose maximal eigenvalue to estimate.</li></ul><p>Must be square and support premultiply (<code>A*⋅</code>).</p><ul><li><code>iters::Int=1</code>: Number of power iterations to run. (Recommended: <code>iters</code> ≤ 3)</li></ul><p><strong>Keywords</strong></p><ul><li><code>p::Real=0.05</code>: Probability that estimate fails to hold as an upper bound.</li></ul><p><strong>Output</strong></p><p>Interval <code>(x, y)</code> which contains the maximal eigenvalue of <code>A</code> with probability <code>1 - p</code>.</p><p><strong>References</strong></p><p>Corollary of Theorem 1 in <sup class="footnote-reference"><a id="citeref-Dixon1983" href="#footnote-Dixon1983">[Dixon1983]</a></sup></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/RandomizedLinAlg.jl/blob/d81c5beb5749f5826cdf56c2f02eb7c27058869f/src/rlinalg.jl#L233-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RandomizedLinAlg.reigmax" href="#RandomizedLinAlg.reigmax"><code>RandomizedLinAlg.reigmax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reigmax(A, iters=1)</code></pre><p>Estimate maximal eigenvalue randomly.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Matrix whose maximal eigenvalue to estimate.</li></ul><p>Must be square and support premultiply (<code>A*⋅</code>).</p><ul><li><code>iters::Int=1</code>: Number of power iterations to run. (Recommended: <code>iters</code> ≤ 3)</li></ul><p><strong>Keywords</strong></p><ul><li><code>p::Real=0.05</code>: Probability that estimate fails to hold as an upper bound.</li></ul><p><strong>Output</strong></p><p>Interval <code>(x, y)</code> which contains the maximal eigenvalue of <code>A</code> with probability <code>1 - p</code>.</p><p><strong>References</strong></p><p>Corollary of Theorem 1 in <sup class="footnote-reference"><a id="citeref-Dixon1983" href="#footnote-Dixon1983">[Dixon1983]</a></sup></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/RandomizedLinAlg.jl/blob/d81c5beb5749f5826cdf56c2f02eb7c27058869f/src/rlinalg.jl#L196-L219">source</a></section></article><h2 id="Norm-estimate"><a class="docs-heading-anchor" href="#Norm-estimate">Norm estimate</a><a id="Norm-estimate-1"></a><a class="docs-heading-anchor-permalink" href="#Norm-estimate" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RandomizedLinAlg.rnorm" href="#RandomizedLinAlg.rnorm"><code>RandomizedLinAlg.rnorm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rnorm(A, mvps)</code></pre><p>Compute a probabilistic upper bound on the norm of a matrix <code>A</code>. <code>‖A‖ ≤ α √(2/π) maxᵢ ‖Aωᵢ‖</code> with probability <code>p=α^(-mvps)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: matrix whose norm to estimate.</li><li><code>mvps::Int</code>: number of matrix-vector products to compute.</li></ul><p><strong>Keywords</strong></p><ul><li><code>p::Real=0.05</code>: probability of upper bound failing.</li></ul><p><strong>Output</strong></p><p>Estimate of ‖A‖.</p><p>See also <a href="#RandomizedLinAlg.rnorms"><code>rnorms</code></a> for a different estimator that uses  premultiplying by both <code>A</code> and <code>A&#39;</code>.</p><p><strong>References</strong></p><p>Lemma 4.1 of Halko2011</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/RandomizedLinAlg.jl/blob/d81c5beb5749f5826cdf56c2f02eb7c27058869f/src/rlinalg.jl#L61-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RandomizedLinAlg.rnorms" href="#RandomizedLinAlg.rnorms"><code>RandomizedLinAlg.rnorms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rnorms(A, iters=1)</code></pre><p>Estimate matrix norm randomly using <code>A&#39;A</code>.</p><p>Compute a probabilistic upper bound on the norm of a matrix <code>A</code>.</p><pre><code class="language-none">ρ = √(‖(A&#39;A)ʲω‖/‖(A&#39;A)ʲ⁻¹ω‖)</code></pre><p>which is an estimate of the spectral norm of <code>A</code> produced by <code>iters</code> steps of the power method starting with normalized <code>ω</code>, is a lower bound on the true norm by a factor</p><pre><code class="language-none">ρ ≤ α ‖A‖</code></pre><p>with probability greater than <code>1 - p</code>, where <code>p = 4\sqrt(n/(iters-1)) α^(-2iters)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: matrix whose norm to estimate.</li><li><code>iters::Int = 1</code>: mumber of power iterations to perform.</li></ul><p><strong>Keywords</strong></p><ul><li><code>p::Real = 0.05</code>: probability of upper bound failing.</li><li><code>At = A&#39;</code>: Transpose of <code>A</code>.</li></ul><p><strong>Output</strong></p><p>Estimate of ‖A‖.</p><p>See also <a href="#RandomizedLinAlg.rnorm"><code>rnorm</code></a> for a different estimator that does not require premultiplying by <code>A&#39;</code></p><p><strong>References</strong></p><p>Appendix of <sup class="footnote-reference"><a id="citeref-Liberty2007" href="#footnote-Liberty2007">[Liberty2007]</a></sup>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/RandomizedLinAlg.jl/blob/d81c5beb5749f5826cdf56c2f02eb7c27058869f/src/rlinalg.jl#L97-L134">source</a></section></article><h2 id="Interpolative-Decomposition"><a class="docs-heading-anchor" href="#Interpolative-Decomposition">Interpolative Decomposition</a><a id="Interpolative-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolative-Decomposition" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RandomizedLinAlg.id" href="#RandomizedLinAlg.id"><code>RandomizedLinAlg.id</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">id(A, k, l)</code></pre><p>Compute and return the interpolative decomposition of <code>A</code>: A ≈ B * P</p><p>Where:</p><ul><li><code>B</code>&#39;s columns are a subset of the columns of <code>A</code></li><li>some subset of <code>P</code>&#39;s columns are the <code>k x k</code> identity, no entry of <code>P</code> exceeds magnitude 2, and</li><li>||B * P - A|| ≲ σ(A, k+1), the (<code>k+1</code>)st singular value of <code>A</code>.</li></ul><p><strong>Arguments</strong></p><p><code>A</code>: Matrix to factorize</p><p><code>k::Int</code>: Number of columns of A to return in B</p><p><code>l::Int</code>: Length of random vectors to project onto</p><p><strong>Output</strong></p><p><code>(::Interpolative)</code>: interpolative decomposition.</p><p><strong>Implementation note</strong></p><p>This is a hacky version of the algorithms described in \cite{Liberty2007} and \cite{Cheng2005}. The former refers to the factorization (3.1) of the latter.  However, it is not actually necessary to compute this factorization in its entirely to compute an interpolative decomposition.</p><p>Instead, it suffices to find some permutation of the first k columns of Y = R * A, extract the subset of A into B, then compute the P matrix as B\A which will automatically compute P using a suitable least-squares algorithm.</p><p>The approximation we use here is to compute the column pivots of Y, rather then use the true column pivots as would be computed by a column- pivoted QR process.</p><p><strong>References</strong></p><p>\cite[Algorithm I]{Liberty2007}</p><pre><code class="language-bibtex">@article{Cheng2005,
    author = {Cheng, H and Gimbutas, Z and Martinsson, P G and Rokhlin, V},
    doi = {10.1137/030602678},
    issn = {1064-8275},
    journal = {SIAM Journal on Scientific Computing},
    month = jan,
    number = {4},
    pages = {1389--1404},
    title = {On the Compression of Low Rank Matrices},
    volume = {26},
    year = {2005}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLinearAlgebra/RandomizedLinAlg.jl/blob/d81c5beb5749f5826cdf56c2f02eb7c27058869f/src/factorization.jl#L22-L78">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Friedland2006"><a class="tag is-link" href="#citeref-Friedland2006">Friedland2006</a>Friedland, Shmuel, et al. &quot;Fast Monte-Carlo low rank approximations for  matrices.&quot; System of Systems Engineering, 2006 IEEE/SMC International  Conference on. IEEE, 2006.</li><li class="footnote" id="footnote-Halko2011"><a class="tag is-link" href="#citeref-Halko2011">Halko2011</a>Halko, Nathan, Per-Gunnar Martinsson, and Joel A. Tropp. &quot;Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions.&quot; SIAM review 53.2 (2011): 217-288.</li><li class="footnote" id="footnote-Dixon1983"><a class="tag is-link" href="#citeref-Dixon1983">Dixon1983</a>Dixon, John D. &quot;Estimating extremal eigenvalues and condition numbers of matrices.&quot; SIAM Journal on Numerical Analysis 20.4 (1983): 812-814.</li><li class="footnote" id="footnote-Liberty2007"><a class="tag is-link" href="#citeref-Liberty2007">Liberty2007</a>Liberty, Edo, et al. &quot;Randomized algorithms for the low-rank approximation of matrices.&quot; Proceedings of the National Academy of Sciences 104.51 (2007): 20167-20172.</li></ul></section></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 18 April 2021 22:27">Sunday 18 April 2021</span>. Using Julia version 1.7.0-DEV.948.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
